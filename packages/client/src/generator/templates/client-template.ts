/**
 * Template for generating the client.ts file
 */
export function generateClientTemplate(
  importPath: string,
  imports: string,
  apiReExports: string,
  apiClientsEntries: string,
  apiEndpointsProps: string,
  useEnhancedLogger: boolean = false,
  useCancellation: boolean = false,
  useDebounce: boolean = false,
): string {
  // Build up the import list
  const importItems = [
    'createAxiosHttpClient',
    'createDefaultHttpClient',
    'type HttpClient',
    'type HttpResponse',
    'type RequestOptions'
  ];
  
  // Add enhanced logger imports if enabled
  if (useEnhancedLogger) {
    importItems.push('EnhancedLogger', 'enhancedLogger', 'ErrorType');
  }
  
  // Add cancellation imports if enabled
  if (useCancellation) {
    importItems.push(
      'CancellationToken',
      'createCancellationToken',
      'createTrackedCancellationToken',
      'cancelAllRequests'
    );
  }
  
  // Add debounce imports if enabled
  if (useDebounce) {
    importItems.push(
      'DebounceManager',
      'createDebounceManager',
      'debounceRequest',
      'cancelAllDebouncedRequests'
    );
  }
  
  // Always include Logger
  importItems.push('Logger');
  
  // Format import items with indentation
  const importList = importItems
    .map(item => `  ${item}`)
    .join(',\n');
  
  return `/**
 * GENERATED CODE - DO NOT MODIFY
 * Generated by openapi-typed-client
 */
import {
${importList}
} from '@arthurmtro/openapi-tools-common';
import { Configuration } from '${importPath}/configuration';
${imports}

// Re-export API classes individually
${apiReExports}

// Re-export models
export * from '${importPath}/models';

/**
 * Request interceptor function type
 * Allows modifying or logging requests before they are sent
 */
export type RequestInterceptor = (config: RequestOptions) => RequestOptions | Promise<RequestOptions>;

/**
 * Response interceptor function type
 * Allows modifying or logging responses before they are returned to the caller
 */
export type ResponseInterceptor = (response: HttpResponse) => HttpResponse | Promise<HttpResponse>;

/**
 * Error interceptor function type
 * Allows handling errors from requests or responses
 */
export type ErrorInterceptor = (error: unknown) => unknown | Promise<unknown>;

// API client configuration options
export interface ApiClientOptions {
  baseUrl?: string;
  timeout?: number;
  headers?: Record<string, string>;
  withCredentials?: boolean;
  auth?: string | (() => string | Promise<string>);
  requestInterceptors?: Array<RequestInterceptor>;
  responseInterceptors?: Array<ResponseInterceptor>;
  errorInterceptors?: Array<ErrorInterceptor>;
  httpClient?: HttpClient;
  httpClientType?: 'fetch' | 'axios';
}

// Group API classes for initialization
export const API_CLIENTS = {
${apiClientsEntries}
};

// Define the type for all API endpoints
export type ApiEndpoints = {
${apiEndpointsProps}
};

// Define the client methods
export interface ApiClientMethods {
  configure: (options: ApiClientOptions) => void;
  getBaseUrl: () => string | undefined;
  getHttpClient: () => HttpClient;
  addRequestInterceptor: (interceptor: RequestInterceptor) => number;
  addResponseInterceptor: (interceptor: ResponseInterceptor) => number;
  addErrorInterceptor: (interceptor: ErrorInterceptor) => void;
  
  // The following methods are optional and only available when the corresponding feature is enabled
  
  ${useCancellation ? `// Request cancellation methods
  createCancellationToken: () => CancellationToken;
  cancelAllRequests: (reason?: string) => void;
  ` : ''}
  
  ${useDebounce ? `// Request debouncing methods
  debounce: <T>(fn: (...args: any[]) => Promise<T>, delay?: number) => (...args: any[]) => Promise<T>;
  cancelAllDebouncedRequests: () => void;
  ` : ''}
}

/**
 * Creates an adapter for Axios-based endpoints from our HttpClient
 * This is for backward compatibility with OpenAPI Generator
 */
function createAxiosAdapter(httpClient: HttpClient): any {
  return {
    request: (config: any) => {
      // Convert axios config to our RequestOptions
      const requestOptions: RequestOptions = {
        url: config.url || '',
        method: (config.method?.toUpperCase() || 'GET') as RequestOptions['method'],
        headers: config.headers || {},
        data: config.data,
        params: config.params,
        responseType: config.responseType,
        timeout: config.timeout,
        withCredentials: config.withCredentials,
      };

      // Use our HTTP client
      return httpClient.request(requestOptions);
    },
    defaults: {
      headers: {
        common: {},
      },
    },
    interceptors: {
      request: {
        use: () => 0,
        eject: () => {},
      },
      response: {
        use: () => 0,
        eject: () => {},
      },
    },
  };
}

/**
 * API client that provides access to API endpoints
 */
export class ApiClient {
  private http: HttpClient;
  private endpoints: Record<string, unknown>;
  private options: ApiClientOptions;
  private interceptorIds: number[] = [];
  private endpointInstances: Record<string, any> = {};

  constructor(endpoints: Record<string, unknown>, options: ApiClientOptions = {}) {
    this.options = {
      requestInterceptors: [],
      responseInterceptors: [],
      errorInterceptors: [],
      ...options
    };
    this.http = this.createHttpClient();
    this.setupInterceptors();
    this.endpoints = this.initializeEndpoints(endpoints);
  }

  /**
   * Creates an HTTP client instance with the configured options
   */
  private createHttpClient(): HttpClient {
    // Use the provided HTTP client if available
    if (this.options.httpClient) {
      return this.options.httpClient;
    }

    // Create a new HTTP client based on the specified type or default
    const clientType = this.options.httpClientType || 'fetch';
    if (clientType === 'axios') {
      try {
        return createAxiosHttpClient({
          baseUrl: this.options.baseUrl,
          timeout: this.options.timeout || 30000,
          headers: this.options.headers || {},
          withCredentials: this.options.withCredentials,
        });
      } catch (error) {
        console.warn('Failed to create Axios HTTP client, falling back to fetch:', error);
        // Fall back to fetch if axios is not available
        return createDefaultHttpClient({
          baseUrl: this.options.baseUrl,
          timeout: this.options.timeout || 30000,
          headers: this.options.headers || {},
          withCredentials: this.options.withCredentials,
        });
      }
    }

    // Default to fetch-based client
    return createDefaultHttpClient({
      baseUrl: this.options.baseUrl,
      timeout: this.options.timeout || 30000,
      headers: this.options.headers || {},
      withCredentials: this.options.withCredentials,
    });
  }

  /**
   * Sets up request and response interceptors
   */
  private setupInterceptors(): void {
    // Clear any existing interceptors
    this.clearInterceptors();
    
    // Add request interceptors
    if (this.options.requestInterceptors?.length) {
      for (const interceptor of this.options.requestInterceptors) {
        const id = this.http.addRequestInterceptor(interceptor, this.createErrorHandler());
        this.interceptorIds.push(id);
      }
    }

    // Add response interceptors
    if (this.options.responseInterceptors?.length) {
      for (const interceptor of this.options.responseInterceptors) {
        const id = this.http.addResponseInterceptor(interceptor, this.createErrorHandler());
        this.interceptorIds.push(id);
      }
    }

    // Add authentication interceptor if auth is provided
    if (this.options.auth) {
      const id = this.http.addRequestInterceptor(
        this.createAuthInterceptor(),
        this.createErrorHandler()
      );
      this.interceptorIds.push(id);
    }
  }

  /**
   * Creates an authentication interceptor based on the auth option
   */
  private createAuthInterceptor(): RequestInterceptor {
    return async (config: RequestOptions): Promise<RequestOptions> => {
      if (!this.options.auth) {
        return config;
      }

      const token = typeof this.options.auth === 'function'
        ? await this.options.auth()
        : this.options.auth;

      if (token) {
        // Set the Authorization header
        return {
          ...config,
          headers: {
            ...config.headers,
            Authorization: \`Bearer \${token}\`,
          },
        };
      }

      return config;
    };
  }

  /**
   * Creates an error handler that applies error interceptors
   */
  private createErrorHandler(): ErrorInterceptor {
    return async (error: unknown): Promise<unknown> => {
      if (this.options.errorInterceptors?.length) {
        let processedError = error;
        
        for (const errorInterceptor of this.options.errorInterceptors) {
          try {
            processedError = await errorInterceptor(processedError);
          } catch (e) {
            processedError = e;
          }
        }
        
        return Promise.reject(processedError);
      }
      
      return Promise.reject(error);
    };
  }

  /**
   * Clears all registered interceptors
   */
  private clearInterceptors(): void {
    for (const id of this.interceptorIds) {
      this.http.removeInterceptor(id);
    }
    this.interceptorIds = [];
  }

  /**
   * Initializes API endpoints with the HTTP client
   */
  private initializeEndpoints(endpoints: Record<string, unknown>): Record<string, unknown> {
    const initialized: Record<string, unknown> = {};

    for (const [key, EndpointClass] of Object.entries(endpoints)) {
      if (typeof EndpointClass === 'function') {
        try {
          // Try to initialize as a modern endpoint with HttpClient
          initialized[key] = new (EndpointClass as any)(
            new Configuration(),
            this.options.baseUrl,
            this.http
          );
        } catch (error) {
          // Fall back to initializing as an axios-based endpoint
          const axiosAdapter = createAxiosAdapter(this.http);
          initialized[key] = new (EndpointClass as any)(
            new Configuration(),
            this.options.baseUrl,
            axiosAdapter
          );
        }
        
        // Store the original instance
        this.endpointInstances[key] = initialized[key];
      } else {
        initialized[key] = EndpointClass;
      }
    }

    return initialized;
  }

  /**
   * Reconfigure the client with new options
   */
  public configure(options: ApiClientOptions): void {
    // Merge options
    this.options = {
      ...this.options,
      ...options,
      // Preserve existing interceptors unless explicitly overridden
      requestInterceptors: options.requestInterceptors || this.options.requestInterceptors,
      responseInterceptors: options.responseInterceptors || this.options.responseInterceptors,
      errorInterceptors: options.errorInterceptors || this.options.errorInterceptors,
    };

    // Create a new HTTP client if needed
    if (options.httpClient || options.httpClientType || options.baseUrl || 
        options.timeout || options.headers || options.withCredentials) {
      this.http = this.createHttpClient();
      this.setupInterceptors();
      this.endpoints = this.initializeEndpoints(this.endpoints);
    }
  }

  /**
   * Add a request interceptor
   */
  public addRequestInterceptor(interceptor: RequestInterceptor): number {
    this.options.requestInterceptors = this.options.requestInterceptors || [];
    this.options.requestInterceptors.push(interceptor);
    
    const id = this.http.addRequestInterceptor(interceptor, this.createErrorHandler());
    this.interceptorIds.push(id);
    
    return id;
  }

  /**
   * Add a response interceptor
   */
  public addResponseInterceptor(interceptor: ResponseInterceptor): number {
    this.options.responseInterceptors = this.options.responseInterceptors || [];
    this.options.responseInterceptors.push(interceptor);
    
    const id = this.http.addResponseInterceptor(interceptor, this.createErrorHandler());
    this.interceptorIds.push(id);
    
    return id;
  }

  /**
   * Add an error interceptor
   */
  public addErrorInterceptor(interceptor: ErrorInterceptor): void {
    this.options.errorInterceptors = this.options.errorInterceptors || [];
    this.options.errorInterceptors.push(interceptor);
  }

  /**
   * Get the base URL
   */
  public getBaseUrl(): string | undefined {
    return this.options.baseUrl;
  }

  /**
   * Get the HTTP client instance
   */
  public getHttpClient(): HttpClient {
    return this.http;
  }

  /**
   * Get access to the API endpoints
   */
  public getEndpoints<T extends object>(): T {
    return this.endpoints as T;
  }

  /**
   * Creates a proxied client for direct access to API endpoints and client methods
   */
  public static createClient<T extends object>(
    endpoints: Record<string, unknown>,
    options: ApiClientOptions = {}
  ): T & ApiClientMethods {
    const client = new ApiClient(endpoints, options);

    return new Proxy({} as T & ApiClientMethods, {
      get: (_, prop: string | symbol) => {
        const propKey = typeof prop === 'symbol' ? prop.toString() : prop;
        
        // Handle client methods
        if (propKey === 'configure') {
          return (newOptions: ApiClientOptions) => client.configure(newOptions);
        }
        if (propKey === 'getBaseUrl') {
          return () => client.getBaseUrl();
        }
        if (propKey === 'getHttpClient') {
          return () => client.getHttpClient();
        }
        if (propKey === 'addRequestInterceptor') {
          return (interceptor: RequestInterceptor) => client.addRequestInterceptor(interceptor);
        }
        if (propKey === 'addResponseInterceptor') {
          return (interceptor: ResponseInterceptor) => client.addResponseInterceptor(interceptor);
        }
        if (propKey === 'addErrorInterceptor') {
          return (interceptor: ErrorInterceptor) => client.addErrorInterceptor(interceptor);
        }
        
        // Handle cancellation methods if enabled
        if (useCancellation) {
          if (propKey === 'createCancellationToken') {
            return () => createTrackedCancellationToken();
          }
          if (propKey === 'cancelAllRequests') {
            return (reason?: string) => cancelAllRequests(reason);
          }
        }
        
        // Handle debounce methods if enabled
        if (useDebounce) {
          if (propKey === 'debounce') {
            return <T>(fn: (...args: any[]) => Promise<T>, delay?: number) => 
              debounceRequest(fn, delay);
          }
          if (propKey === 'cancelAllDebouncedRequests') {
            return () => cancelAllDebouncedRequests();
          }
        }

        // Handle API endpoints
        const endpoints = client.getEndpoints<T>();
        const stringKey = typeof propKey === 'string' 
          ? propKey 
          : propKey.replace(/^Symbol\((.*)\)$/, '$1');
        
        // Check if the key exists in the API endpoints
        if (typeof stringKey === 'string' && stringKey in endpoints) {
          return endpoints[stringKey as keyof typeof endpoints];
        }

        return undefined;
      }
    });
  }
}

/**
 * Create a typed API client instance
 */
export const createApiClient = (baseUrl = '', options = {}): ApiEndpoints & ApiClientMethods => {
  return ApiClient.createClient<ApiEndpoints>(API_CLIENTS, {
    baseUrl,
    ...options
  });
};

// Set the logger level
export const setLogLevel = (level: 'silent' | 'error' | 'warn' | 'info' | 'debug'): void => {
  try {
    ${useEnhancedLogger ? 'logger.setLevel(level);' : 'Logger.setLevel(level);'}
  } catch (e) {
    console.warn('Failed to set log level:', e);
  }
};

${useCancellation ? `
// Re-export cancellation utilities for public use
export { CancellationToken, cancelAllRequests };

/**
 * Creates a cancellation token for aborting requests
 * Tokens created with this function are tracked and can be cancelled with cancelAllRequests()
 */
export const createCancellationToken = (): CancellationToken => {
  return createTrackedCancellationToken();
};` : ''}

${useDebounce ? `
// Re-export debouncing utilities for public use
export { cancelAllDebouncedRequests };

/**
 * Creates a debounced version of a request function
 * 
 * @example
 * const debouncedSearch = client.debounce(
 *   (query: string) => client.search.searchItems({ query }),
 *   300 // 300ms delay
 * );
 * 
 * // This will only execute the last call
 * debouncedSearch('t');
 * debouncedSearch('te');
 * debouncedSearch('tes');
 * debouncedSearch('test');
 * 
 * @param fn Function to debounce
 * @param delay Delay in milliseconds
 * @returns Debounced function
 */
export const debounce = <T>(
  fn: (...args: any[]) => Promise<T>,
  delay: number = 300
): (...args: any[]) => Promise<T> => {
  return debounceRequest(fn, delay);
};` : ''}

${useEnhancedLogger ? `
// Initialize the enhanced logger with the configured log level
const logger = enhancedLogger;
// Initialize with info level by default
try {
  logger.setLevel('info');
} catch (e) {
  console.warn('Failed to set initial log level:', e);
}

// Export error types for client usage
export { ErrorType };

// Create a default error interceptor for better error reporting
export const createDefaultErrorInterceptor = () => {
  try {
    return logger.createErrorInterceptor();
  } catch (e) {
    console.warn('Failed to create error interceptor:', e);
    return (error: unknown) => Promise.reject(error);
  }
};
` : '// Initialize logger with info level by default\ntry {\n  Logger.setLevel("info");\n} catch (e) {\n  console.warn("Failed to set initial log level:", e);\n}'}

// Create a default client instance
export const api = createApiClient(${useEnhancedLogger || useCancellation || useDebounce ? `undefined, undefined, {
  ${useEnhancedLogger ? `errorInterceptors: [createDefaultErrorInterceptor()],` : ''}
  ${useCancellation || useDebounce ? `// Configure HTTP client with advanced features
  httpClientOptions: {
    ${useCancellation ? `cancellation: {
      enabled: true
    },` : ''}
    ${useDebounce ? `debounce: {
      enabled: true,
      delay: 300,
      cancelPending: true
    }` : ''}
  }` : ''}
}` : ''});
`;
}
